// ライフタイム

// ライフタイムは全ての参照がもつスコープのこと。生きてる範囲
// 通常は推論されるので明記しなくていい
// コンパイラに推論ができないケースのときは、明記しないをコンパイルエラーになる

// 実際は、ある関数の参照引数(たち)と、参照戻り値を繋げるために明記することがほぼ。

// ライフタイム推論は、３つの規則に則って行われる
//
// １）関数における複数の参照引数は、それぞれの独自ライフタイムを付与される
//　　 fn foo<'a, 'b>(x: &'a i32, y: &'b i32){}
//
// ２）入力ライフタイム(引数)がひとつだけなら、全ての出力ライフタイム(戻り値)も同じに決定される
//　　 fn foo<'a>(x: &'a i32) -> &'a i32 {}
//
// ３) 複数の入力ライフタイムがあっても、&self, &mut self が含まれてればそのライフタイムが全出力ライフタイムに設定される
//　　 これは専ら impl 内関数での話になる。
/*

    １入力なので推論可
    fn foo(x: &str) -> &str {
        //
    }

    ２入力だけど、出力変数が確定してるから推論可
    fn foo(x: &str, y: &str) -> &str {
        x
    }

    ２入力かつ、どちらが出力されるか分からない → 推論不可
    ＜このときにライフタイム注釈が必要になる＞
    fn foo<'a>(x: &'a str, y: &'a str) -> &'a str {
        if(x > y) { x }
        else { y }
    }
    こうすることでライフタイムが 'a に揃えられる
    実際は、x, y の短いほうのライフタイムに整えられる
*/

// 記法
// &i32　ただの参照
// &'a i32　明示的なライフタイムつき参照
// &'a mut i32　明示的ライフタイムつき可変参照
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// 構造体に参照を保持させる
//
// この場合、その構造体に関わる全ての参照にライフタイム注釈が必要。
// つまり全てのライフタイムを、その中の一番短いものに揃えておく必要がある
struct ImportantExcept<'a> { // 構造体名のあとに書く
    part: &'a str, // ライフタイム明記
}
impl<'a> ImportantExcept<'a> { // ライフタイム注釈つき構造体の impl 実装にも 'a 書かないとならない。２箇所に書く
    fn level(&self) -> i32 {
        3
    }
}

fn main() {
    let result;
    let str1 = String::from("str1aaaaaaaaaa");
    {
        let str2 = String::from("str2");
        result = longest(str1.as_str(), str2.as_str());
        println!("longest: {}", result);
    }
    // 明らかに str1 が longest として帰ってくると分かっていても、
    // longest 関数内でライフタイムが str2 に揃えられてるため、ここはスコープ外でエラー
    //
    // str2 に関しても、関数を通して戻ってきてもあくまでも str2 と同じライフタイムとして機能するので、
    // スコープ外でエラー
    //
    // println!("longest: {}", result); エラー


    // 文字列参照を構造体に保持させる
    // これにはライフタイム注釈が必須で、stri のライフタイムと揃うことになる
    // つまりこのインスタンスは stri のスコープ内でしか使えない
    let stri = String::from("atrrrr");
    let i = ImportantExcept {
        part: stri.as_str(),
    };
    println!("struct level {}", i.level());



    // 静的ライフタイム
    // &'static　と書く。乱用しないこと
    //
    // プログラム実行中ずっと参照可能なもの
    // 文字列リテラルはすべてこれにあたる
    let s: &'static str = "sdsdsds";
}

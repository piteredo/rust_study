fn main() {

    // 型は自動で推論される。整数のデフォは i32 (符号付整数32ビット)
    // 整数型は 他に i16, i32, i64, u16, u32, u64, isize, usize がある
    // uXX は符号なし整数 unsigned。０以上確定時に明示的に使える。
    // Xsize はコンピュータの種類(32bit 64bit)に依存（使い道？
    let n1 = 30;
    println!("{}", n1);

    // 型が２種類あり得るような場合は明示する必要
    // 下記は parse() しないと string か int か分からない
    let n2: u32 = "33".trim().parse().expect("type NUMBER!");
    println!("{}", n2);

    // 数値リテラル（８進法以外 java と同じ
    // 10:100_000, 16:0x123, 8:0o123, 2:0b0000_0000

    // 浮動小数点型
    // f32, f64 の２つ。デフォは f64 のほう！
    let n3 = 2.0; // f64
    let n4: f32 = 3.0; //f32
    println!("{} {}", n3, n4);

    // 数値演算は同じ

    // 論理値
    // true, false (頭文字は小文字)。bool と書く(booleanじゃない)
    let t = true;
    let f: bool = false;
    println!("{} {}", t, f);

    // 文字型
    // char。ACIIじゃなくてUNICODEである！
    let c = 'c';
    let cat_mark = '🐈'; // こんなのも使える
    println!("{} {}", c, cat_mark);



    // ---------------------------------------------------
    // 複合型 (タプル型 と 配列型)


    // タプル型
    // 型の違う 複数の値をひとまとめにできる
    let tup: (i32, f64, char) = (500, 6.4, 'f');
    // println!("{}", tup); これで一気に出力はできない。コンパイルエラー
    println!("{} {} {}", tup.0, tup.1, tup.2); // . 添え字 で各要素にアクセスできる

    let (x, y, z) = tup; // これで分解できる
    println!("{} {} {}", x, y, z); // でアクセス可能

    let (a, b, c) = (20, 2.0, "fff"); // これで型推論でタプル生成可能。危険？
    println!("{} {} {}", a, b, c);


    // 配列型
    // サイズ変更不可能、違う型入れられない。いつもと同じ感じ
    // タプルと使い分け => 要素数が不変のものに使う（１～12月とか
    let arr = [1, 2, 3, 4, 5];
    println!("{}", arr[2]);
    // arr[10] の様な範囲外へのアクセスは、コンパイルは通るが、
    // 実行時エラーになり止まる == 範囲外のメモリを取得してその後のバグを生むようなことにはならない！
}
